<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–†–æ–±–∏–Ω–∑–æ–Ω ‚Äî –∏–≥—Ä–∞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#021b3b" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #021b3b;
      color: #fff;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 10px 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
      z-index: 10;
      pointer-events: none;
    }
    #ui-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      pointer-events: auto;
    }
    #logo {
      font-weight: 800;
      letter-spacing: 1px;
      font-size: 18px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      background: #ffb000;
      color: #421b00;
      box-shadow: 0 2px 6px rgba(0,0,0,.4);
      white-space: nowrap;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }
    #auth-panel {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      pointer-events: auto;
      padding: 0 2px;
    }
    #stats {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 1px 3px rgba(0,0,0,.7);
      padding: 0 2px;
    }
    #status-text {
      font-weight: 600;
    }
    #balance-box {
      font-weight: 600;
    }
    #canvas-container {
      position: absolute;
      inset: 0;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* –ú–æ–±–∏–ª—å–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞ */
    #splash {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, #0747a6 0%, #021b3b 40%, #000814 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: opacity 0.4s ease;
    }
    #splash.hidden {
      opacity: 0;
      pointer-events: none;
    }
    #splash-inner {
      width: 100%;
      max-width: 360px;
      padding: 24px 20px calc(24px + env(safe-area-inset-bottom));
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    #splash-logo {
      font-size: 24px;
      font-weight: 800;
      letter-spacing: 1.5px;
    }
    #splash-logo span {
      font-size: 30px;
      margin-right: 6px;
    }
    #splash-subtitle {
      font-size: 14px;
      opacity: 0.85;
    }
    #splash-hint {
      font-size: 12px;
      opacity: 0.6;
    }
    #splash-start-btn {
      margin-top: 4px;
      padding: 12px 24px;
      font-size: 16px;
      width: 100%;
    }

    /* –ù–∏–∂–Ω–µ–µ —Ç–∞–±–ª–æ */
    #bottom-ui {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      min-height: 80px;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
      justify-content: space-around;
      padding: 8px 16px calc(8px + env(safe-area-inset-bottom, 0px));
      z-index: 2000;
      pointer-events: auto;
    }
    #bottom-ui, #bottom-ui * {
      color: #ffffff;
    }
    .bottom-item {
      font-size: 16px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 2px;
      pointer-events: auto;
    }
    .bottom-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.7;
      letter-spacing: .06em;
    }
    .bottom-value {
      font-size: 18px;
      font-weight: 700;
    }
    #bottom-bet {
      cursor: pointer;
    }
    #start-round-btn {
      background: #ffffff;
      border-radius: 50%;
      width: 72px;
      height: 72px;
      font-size: 30px;
      font-weight: 800;
      color: #000;
      border: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    #start-round-btn:disabled {
      opacity: 0.4;
      box-shadow: none;
    }
  </style>
</head>
<body>
  <!-- –ó–∞—Å—Ç–∞–≤–∫–∞ -->
  <div id="splash">
    <div id="splash-inner">
      <div id="splash-logo"><span>üèùÔ∏è</span>–†–û–ë–ò–ù–ó–û–ù</div>
      <div id="splash-subtitle">
        –õ–µ—Ç–∏ –∫ –æ—Å—Ç—Ä–æ–≤—É, —Å–æ–±–∏—Ä–∞–π –±–æ–Ω—É—Å—ã –∏ —É–º–Ω–æ–∂–∞–π –≤—ã–∏–≥—Ä—ã—à.
      </div>
      <button id="splash-start-btn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
      <div id="splash-hint">
        –°–æ–≤–µ—Ç: –≤—ã–±–µ—Ä–∏ —Å—Ç–∞–≤–∫—É (–≤–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞), –∞ –∑–∞—Ç–µ–º –∂–º–∏ ‚ñ∂.
      </div>
    </div>
  </div>

  <!-- –í–µ—Ä—Ö–Ω–∏–π UI -->
  <div id="ui">
    <div id="ui-top">
      <div id="logo">üèùÔ∏è –†–û–ë–ò–ù–ó–û–ù</div>
    </div>

    <div id="auth-panel">
      <button id="deposit-btn">–î–µ–ø–æ–∑–∏—Ç</button>
    </div>

    <div id="stats">
      <div>–ú–Ω–æ–∂–∏—Ç–µ–ª—å: <span id="multiplier">1.00x</span></div>
      <div id="balance-box">–ë–∞–ª–∞–Ω—Å: <span id="balance">0.00</span> ü™ô</div>
    </div>
    <div id="status-text">–°–¥–µ–ª–∞–π —Å—Ç–∞–≤–∫—É –∏ –Ω–∞–∂–º–∏ ‚ñ∂</div>
  </div>

  <!-- –ù–∏–∂–Ω–µ–µ —Ç–∞–±–ª–æ -->
  <div id="bottom-ui">
    <div class="bottom-item" id="bottom-balance">
      <div class="bottom-label">Balance</div>
      <div class="bottom-value" id="balance-bottom">0.00</div>
    </div>

    <button id="start-round-btn">‚ñ∂</button>

    <div class="bottom-item" id="bottom-bet">
      <div class="bottom-label">Bet</div>
      <div class="bottom-value" id="bet-bottom">1.00</div>
    </div>
  </div>

  <div id="canvas-container">
    <canvas id="game"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const multiplierEl = document.getElementById("multiplier");
    const statusEl = document.getElementById("status-text");
    const startBtn = document.getElementById("start-round-btn");
    const balanceEl = document.getElementById("balance");
    const balanceBottomEl = document.getElementById("balance-bottom");
    const betBottomEl = document.getElementById("bet-bottom");
    const depositBtn = document.getElementById("deposit-btn");

    const splash = document.getElementById("splash");
    const splashStartBtn = document.getElementById("splash-start-btn");

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.src = src;
        img.onload = () => res(img);
        img.onerror = rej;
      });
    }

    const assets = {};
    const ASSET_LIST = {
      bg: "assets/bg_ocean.png",
      rob: "assets/robinson.png",
      island: "assets/island_long.png",
      bird: "assets/bird_spritesheet.png",
      x2: "assets/bonus_x2.png",
      x3: "assets/bonus_x3.png",
      x5: "assets/bonus_x5.png",
      x10: "assets/bonus_x10.png",
      x20: "assets/bonus_x20.png",
      x50: "assets/bonus_x50.png",
      x100: "assets/bonus_x100.png",
      gameover: "assets/game_over.png"   // –¢–í–û–Ø PNG "–†–æ–±–∏–Ω–∑–æ–Ω —É–ø–∞–ª –≤ –≤–æ–¥—É"
    };

    let allLoaded = false;

    (async function preload() {
      for (const [key, src] of Object.entries(ASSET_LIST)) {
        assets[key] = await loadImage(src).catch(() => null);
      }
      allLoaded = true;
      statusEl.textContent = "–ì–æ—Ç–æ–≤–æ –∫ –∏–≥—Ä–µ";
      initProfile();
    })();

    let state = "idle"; // idle | flying | won | lost
    let robinson;
    let objects;
    let time;
    let lastTs;
    let multiplier;
    let baseBet = 1;

    let userBalance = 100;

    const HERO_X_REL = 0.25;
    const OBJECT_SPEED = 380;
    const ISLAND_BASE_PROB = 0.012;

    const BIRD_PROB   = 0.06;
    const BONUS_PROB  = 0.06;

    const WATER_LINE_REL = 0.93; // –ª–∏–Ω–∏—è –æ—Å—Ç—Ä–æ–≤–æ–≤ / –≤–æ–¥—ã (–≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö)
    const GRAVITY_BASE = 75;
    let gravity = GRAVITY_BASE;

    let bonusPulse = 0;
    let robinsonAnimTime = 0;
    let shoutVisible = 0;
    let cameraY = 0;
    let cameraLockY = null;

    let splashParticles = [];
    let hasSplashed = false;
    let heroVisible = true;

    function resetRound() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      robinson = {
        x: w * HERO_X_REL,
        y: h * 0.5,
        vy: -170,
        width: 72,
        height: 72,
      };

      gravity = GRAVITY_BASE;
      objects = [];
      splashParticles = [];
      hasSplashed = false;
      heroVisible = true;
      time = 0;
      multiplier = 1;
      lastTs = performance.now();
      bonusPulse = 0;
      robinsonAnimTime = 0;
      shoutVisible = 0;
      cameraY = 0;
      cameraLockY = null;
      multiplierEl.textContent = "1.00x";

      const baseX = w * 0.55;
      const spacing = 150;
      const startBonuses = ["x2", "x3", "x5", "x2", "x10", "x3"];
      const bonusSize = 38;

      startBonuses.forEach((kind, i) => {
        const yOffset = (Math.random() * 0.12 - 0.06) * h;
        objects.push({
          type: "bonus",
          kind,
          x: baseX + i * spacing,
          y: robinson.y + yOffset,
          w: bonusSize,
          h: bonusSize,
          phase: Math.random() * Math.PI * 2,
        });
      });
    }

    function initProfile() {
      userBalance = 100;
      updateBalanceUI();
      statusEl.textContent = "–î–µ–º–æ-—Ä–µ–∂–∏–º: —É —Ç–µ–±—è 100 –º–æ–Ω–µ—Ç";
      betBottomEl.textContent = baseBet.toFixed(2);
    }

    function updateBalanceUI() {
      balanceEl.textContent = userBalance.toFixed(2);
      balanceBottomEl.textContent = userBalance.toFixed(2);
    }

    depositBtn.addEventListener("click", () => {
      const amountStr = prompt("–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å (–º–æ–Ω–µ—Ç—ã):");
      const amount = parseFloat(amountStr || "0");
      if (!amount || amount <= 0) return;
      userBalance += amount;
      updateBalanceUI();
      statusEl.textContent = "–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω";
    });

    document.getElementById("bottom-bet").addEventListener("click", () => {
      const valueStr = prompt("–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É", baseBet.toFixed(2));
      const val = parseFloat(valueStr || "");
      if (!val || val <= 0) return;
      baseBet = val;
      betBottomEl.textContent = baseBet.toFixed(2);
    });

    function startRound() {
      if (!allLoaded) return;

      if (userBalance < baseBet) {
        statusEl.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç. –ü–æ–ø–æ–ª–Ω–∏ –±–∞–ª–∞–Ω—Å.";
        return;
      }

      userBalance -= baseBet;
      updateBalanceUI();

      resetRound();
      state = "flying";
      statusEl.textContent = "–†–æ–±–∏–Ω–∑–æ–Ω –≤ –ø–æ–ª—ë—Ç–µ...";
      startBtn.disabled = true;
    }

    startBtn.addEventListener("click", () => {
      if (state === "idle" || state === "won" || state === "lost") {
        startRound();
      }
    });

    splashStartBtn.addEventListener("click", () => {
      splash.classList.add("hidden");
    });

    function finishRound(win) {
      if (win) {
        const winAmount = baseBet * multiplier;
        userBalance += winAmount;
        updateBalanceUI();
        statusEl.textContent += ` –í—ã–∏–≥—Ä—ã—à: ${winAmount.toFixed(2)}.`;
      }
    }

    function getLastOfType(type) {
      for (let i = objects.length - 1; i >= 0; i--) {
        if (objects[i].type === type) return objects[i];
      }
      return null;
    }

    function spawnIsland() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const width = 260;
      const height = 80;
      const y = h * 0.93;

      const x = w + width * 0.6;
      const last = getLastOfType("island");
      const minGap = 260;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "island",
        x,
        y,
        w: width,
        h: height,
      });
    }

    function spawnBird() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const size = 58;
      const y = h * (0.18 + Math.random() * 0.37); // –≤—ã—à–µ
      const x = w + size * 0.8;
      const last = getLastOfType("bird");
      const minGap = 180;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "bird",
        x,
        y,
        w: size,
        h: size,
        phase: Math.random() * Math.PI * 2,
      });
    }

    const BONUS_WEIGHTS = [
      { key: "x2",   w: 40 },
      { key: "x3",   w: 30 },
      { key: "x5",   w: 15 },
      { key: "x10",  w: 8  },
      { key: "x20",  w: 4  },
      { key: "x50",  w: 2  },
      { key: "x100", w: 1  },
    ];

    function randomBonusKey() {
      let total = 0;
      for (const b of BONUS_WEIGHTS) total += b.w;
      let r = Math.random() * total;
      for (const b of BONUS_WEIGHTS) {
        if (r < b.w) return b.key;
        r -= b.w;
      }
      return "x2";
    }

    function spawnBonus() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const size = 38;
      const y = h * (0.22 + Math.random() * 0.38); // —Ç–æ–∂–µ –≤—ã—à–µ
      const x = w + size * 0.6;
      const last = getLastOfType("bonus");
      const minGap = 220;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "bonus",
        kind: randomBonusKey(),
        x,
        y,
        w: size,
        h: size,
        phase: Math.random() * Math.PI * 2,
      });
    }

    function isColliding(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function createSplash(x, waterY) {
      const count = 22;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI - Math.PI / 2; // –≤–≤–µ—Ä—Ö
        const speed = 180 + Math.random() * 140;
        splashParticles.push({
          x,
          y: waterY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed * 0.8,
          life: 0,
          maxLife: 0.7 + Math.random() * 0.3,
          r: 2 + Math.random() * 3,
        });
      }
    }

    function update(dt) {
      time += dt;
      bonusPulse = Math.max(0, bonusPulse - dt);
      robinsonAnimTime += dt;

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const waterY = h * WATER_LINE_REL;

      // –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤—Å–ø–ª–µ—Å–∫–∞
      for (const p of splashParticles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 350 * dt;
        p.life += dt;
      }
      splashParticles = splashParticles.filter(p => p.life < p.maxLife);

      if (state === "flying") {
        if (shoutVisible > 0) {
          shoutVisible -= dt;
        } else if (Math.random() < 0.8 * dt) {
          shoutVisible = 0.35;
        }
      } else {
        shoutVisible = 0;
      }

      if (state === "idle" || state === "won") {
        cameraY = -(robinson.y - h * 0.55) * 0.1; // 10%
        cameraLockY = null;
        return;
      }

      if (state === "lost") {
        if (cameraLockY === null) {
          cameraLockY = cameraY;
        }
        cameraY = cameraLockY; // –∫–∞–º–µ—Ä–∞ –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞
        return;
      }

      // FLYING
      robinson.vy += gravity * dt;
      robinson.y += robinson.vy * dt;

      const topLimit = h * 0.12;
      if (robinson.y < topLimit) {
        robinson.y = topLimit;
        if (robinson.vy < 0) robinson.vy = 0;
      }

      // –ø–∞–¥–µ–Ω–∏–µ –≤ –≤–æ–¥—É
      if (robinson.y + robinson.height / 2 >= waterY) {
        state = "lost";
        statusEl.textContent = "–†–æ–±–∏–Ω–∑–æ–Ω —É–ø–∞–ª –≤ –≤–æ–¥—É";
        startBtn.disabled = false;
        if (!hasSplashed) {
          createSplash(robinson.x, waterY);
          hasSplashed = true;
        }
        heroVisible = false;
        finishRound(false);
        return;
      }

      const islandProb = Math.max(0.0005, ISLAND_BASE_PROB / (1 + multiplier * 0.1));
      if (Math.random() < islandProb) spawnIsland();
      if (Math.random() < BIRD_PROB)  spawnBird();
      if (Math.random() < BONUS_PROB) spawnBonus();

      const dx = OBJECT_SPEED * dt;
      objects.forEach((o) => { o.x -= dx; });

      const heroBox = {
        x: robinson.x - robinson.width * 0.35,
        y: robinson.y - robinson.height * 0.35,
        w: robinson.width * 0.7,
        h: robinson.height * 0.7,
      };

      for (const o of objects) {
        const ow = o.w * 0.8;
        const oh = o.h * 0.8;
        const box = {
          x: o.x - ow / 2,
          y: o.y - oh / 2,
          w: ow,
          h: oh,
        };

        if (!isColliding(heroBox, box)) continue;

        if (o.type === "island") {
          state = "won";
          statusEl.textContent = "–ü–æ–±–µ–¥–∞! –†–æ–±–∏–Ω–∑–æ–Ω –ø—Ä–∏–∑–µ–º–ª–∏–ª—Å—è –Ω–∞ –æ—Å—Ç—Ä–æ–≤";
          startBtn.disabled = false;
          o._dead = true;
          finishRound(true);
          break;
        }

        if (o.type === "bird") {
          multiplier = Math.max(1, multiplier / 2);
          multiplierEl.textContent = multiplier.toFixed(2) + "x";
          statusEl.textContent = "–ü—Ç–∏—Ü–∞! –í—ã–∏–≥—Ä—ã—à —É–º–µ–Ω—å—à–µ–Ω";
          gravity = Math.min(gravity + 50, GRAVITY_BASE * 2.5);
          robinson.vy += 50;
          o._dead = true;
        }

        if (o.type === "bonus") {
          const val = parseInt(o.kind.slice(1));
          multiplier *= val;
          multiplierEl.textContent = multiplier.toFixed(2) + "x";
          statusEl.textContent = "–ë–æ–Ω—É—Å " + o.kind + "!";
          robinson.vy = -230;
          gravity = Math.max(GRAVITY_BASE * 0.8, gravity - 20);
          bonusPulse = 0.25;
          o._dead = true;
        }
      }

      objects = objects.filter(o => o.x + o.w > -50 && !o._dead);

      cameraY = -(robinson.y - h * 0.55) * 0.1; // –∫–∞–º–µ—Ä–∞ 10%
      cameraLockY = null;
    }

    function drawBackground() {
      const bg = assets.bg;
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      if (bg) {
        const scale = h / bg.height;
        const imgW = bg.width * scale;
        for (let x = 0; x < w + imgW; x += imgW) {
          ctx.drawImage(bg, x, cameraY * 0.15, imgW, h);
        }
      } else {
        ctx.fillStyle = "#4cc3ff";
        ctx.fillRect(0, 0, w, h);
      }
    }

    // –≤—Å—ë –Ω–∏–∂–µ –ª–∏–Ω–∏–∏ –æ—Å—Ç—Ä–æ–≤–æ–≤ ‚Äî –º–æ—Ä–µ —Å –≤–æ–ª–Ω–∞–º–∏
    function drawWaterRegion() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const worldWaterY = h * WATER_LINE_REL;
      const baseY = worldWaterY + cameraY;

      const waveAmp = 6;
      const waveLen = 80;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, baseY + Math.sin(time * 2) * 2);
      for (let x = 0; x <= w; x += 20) {
        const y = baseY + Math.sin((x / waveLen) + time * 2) * waveAmp;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();

      const g = ctx.createLinearGradient(0, baseY, 0, h);
      g.addColorStop(0, "rgba(0, 130, 220, 0.95)");
      g.addColorStop(0.4, "rgba(0, 90, 180, 0.98)");
      g.addColorStop(1, "rgba(0, 40, 90, 1)");

      ctx.fillStyle = g;
      ctx.fill();

      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.beginPath();
      for (let x = 0; x <= w; x += 16) {
        const y = baseY + Math.sin((x / waveLen) + time * 2.5) * (waveAmp * 0.6);
        ctx.moveTo(x - 4, y);
        ctx.lineTo(x + 4, y);
      }
      ctx.stroke();

      ctx.restore();
    }

    function drawSplash() {
      if (!splashParticles.length) return;
      ctx.save();
      for (const p of splashParticles) {
        const alpha = 1 - p.life / p.maxLife;
        if (alpha <= 0) continue;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(230, 245, 255, 1)";
        ctx.beginPath();
        ctx.arc(p.x, p.y + cameraY, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawHero() {
      if (!heroVisible) return;
      const img = assets.rob;
      if (!img) return;

      const pulse = bonusPulse > 0 ? (bonusPulse / 0.25) : 0;

      const tilt = Math.sin(robinsonAnimTime * 6) * 0.18;
      const bobY = Math.sin(robinsonAnimTime * 3) * 4;

      const scale = 1 + 0.25 * pulse;

      ctx.save();
      ctx.translate(robinson.x, robinson.y + bobY + cameraY);
      ctx.rotate(tilt);
      ctx.scale(scale, scale);

      ctx.drawImage(
        img,
        -robinson.width / 2,
        -robinson.height / 2,
        robinson.width,
        robinson.height
      );

      ctx.restore();

      if (shoutVisible > 0) {
        const alpha = Math.min(1, shoutVisible / 0.15);
        const px = robinson.x;
        const py = robinson.y + cameraY - robinson.height * 0.7;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.strokeStyle = "rgba(0,0,0,0.6)";
        ctx.lineWidth = 2;

        const w = 48;
        const h = 24;
        const r = 8;

        ctx.beginPath();
        ctx.moveTo(px - w/2 + r, py - h/2);
        ctx.lineTo(px + w/2 - r, py - h/2);
        ctx.quadraticCurveTo(px + w/2, py - h/2, px + w/2, py - h/2 + r);
        ctx.lineTo(px + w/2, py + h/2 - r);
        ctx.quadraticCurveTo(px + w/2, py + h/2, px + w/2 - r, py + h/2);
        ctx.lineTo(px - w/2 + r, py + h/2);
        ctx.quadraticCurveTo(px - w/2, py + h/2, px - w/2, py + h/2 - r);
        ctx.lineTo(px - w/2, py - h/2 + r);
        ctx.quadraticCurveTo(px - w/2, py - h/2, px - w/2 + r, py - h/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(px - 4, py + h/2);
        ctx.lineTo(px - 12, py + h/2 + 10);
        ctx.lineTo(px, py + h/2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#000";
        ctx.font = "bold 12px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("–ê-–ê-–ê!", px - 1, py);

        ctx.restore();
      }
    }

    function drawWinAboveHero() {
      if (!heroVisible) return;
      const px = robinson.x;
      const py = robinson.y + cameraY - robinson.height * 0.6;

      const winNow = baseBet * multiplier;
      const text = winNow.toFixed(2) + " RUB";

      ctx.save();
      ctx.font = "bold 20px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.strokeStyle = "rgba(0,0,0,0.7)";
      ctx.lineWidth = 4;
      ctx.strokeText(text, px, py);
      ctx.fillStyle = "#ffffff";
      ctx.fillText(text, px, py);
      ctx.restore();
    }

    function drawObjects() {
      for (const o of objects) {
        let drawY = o.y;

        if (o.type === "bonus" || o.type === "bird") {
          const amp = o.type === "bonus" ? 4 : 6;
          const freq = o.type === "bonus" ? 3 : 2.5;
          drawY = o.y + Math.sin(time * freq + (o.phase || 0)) * amp;
        }

        if (o.type === "island" && assets.island) {
          ctx.drawImage(
            assets.island,
            o.x - o.w / 2,
            o.y - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
        if (o.type === "bonus" && assets[o.kind]) {
          ctx.drawImage(
            assets[o.kind],
            o.x - o.w / 2,
            drawY - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
        if (o.type === "bird" && assets.bird) {
          ctx.drawImage(
            assets.bird,
            o.x - o.w / 2,
            drawY - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
      }
    }

    // PNG "–†–æ–±–∏–Ω–∑–æ–Ω —É–ø–∞–ª –≤ –≤–æ–¥—É" + –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ —Ñ–æ–Ω–∞
    function drawGameOverOverlay() {
      if (state !== "lost") return;

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      ctx.save();

      // –∑–∞—Ç–µ–º–Ω—è–µ–º —ç–∫—Ä–∞–Ω (–∫–∞–Ω–≤–∞—Å), –Ω–∏–∂–Ω–µ–µ –º–µ–Ω—é ‚Äî –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å–ª–æ–π, –Ω–µ —Ç—Ä–æ–≥–∞–µ–º –µ–≥–æ
      ctx.fillStyle = "rgba(0, 0, 0, 0.55)";
      ctx.fillRect(0, 0, w, h);

      const img = assets.gameover;
      if (img) {
        const maxW = w * 0.7;
        const maxH = h * 0.4;
        const scale = Math.min(maxW / img.width, maxH / img.height);
        const iw = img.width * scale;
        const ih = img.height * scale;
        const x = w / 2 - iw / 2;
        const y = h / 2 - ih / 2;
        ctx.drawImage(img, x, y, iw, ih);
      } else {
        // –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ PNG –µ—â—ë –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞
        const text1 = "–†–æ–±–∏–Ω–∑–æ–Ω —É–ø–∞–ª –≤ –≤–æ–¥—É.";
        const text2 = "–î–æ–±–∞–≤—å assets/game_over.png";
        ctx.font = "bold 20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.strokeStyle = "rgba(0,0,0,0.8)";
        ctx.lineWidth = 4;
        ctx.strokeText(text1, w / 2, h / 2 - 8);
        ctx.strokeText(text2, w / 2, h / 2 + 20);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text1, w / 2, h / 2 - 8);
        ctx.fillText(text2, w / 2, h / 2 + 20);
      }

      ctx.restore();
    }

    function render() {
      const now = performance.now();
      const dt = (now - lastTs) / 1000;
      lastTs = now;

      update(dt);

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      ctx.clearRect(0, 0, w, h);

      drawBackground();
      drawWaterRegion();
      drawObjects();
      drawHero();
      drawWinAboveHero();
      drawSplash();
      drawGameOverOverlay();

      requestAnimationFrame(render);
    }

    lastTs = performance.now();
    resetRound();
    requestAnimationFrame(render);
  </script>
</body>
</html>
