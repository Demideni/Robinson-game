<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–†–æ–±–∏–Ω–∑–æ–Ω ‚Äî –∏–≥—Ä–∞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#021b3b" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #021b3b;
      color: #fff;
    }

    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 10px 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: linear-gradient(to bottom, rgba(0,0,0,.6), rgba(0,0,0,0));
      z-index: 10;
      pointer-events: none;
    }
    #ui-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      pointer-events: auto;
    }
    /* –õ–æ–≥–æ—Ç–∏–ø –ö–†–£–ü–ù–ï–ï (2.5x) */
    #logo {
      width: 325px;  /* –±—ã–ª–æ 130 */
      height: 80px;  /* –±—ã–ª–æ 32 */
      background: url('assets/logo_robinson.png') no-repeat left center / contain;
      text-indent: -9999px;
      overflow: hidden;
      flex-shrink: 0;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      background: #ffb000;
      color: #421b00;
      box-shadow: 0 2px 6px rgba(0,0,0,.4);
      white-space: nowrap;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }

    #auth-panel {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      pointer-events: auto;
      padding: 0 2px;
      flex-shrink: 0;
    }

    /* –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é –ö–†–£–ü–ù–ï–ï (2.5x) */
    #menu-btn {
      width: 80px;   /* –±—ã–ª–æ 32 */
      height: 80px;  /* –±—ã–ª–æ 32 */
      padding: 0;
      border-radius: 50%;
      background: url('assets/btn_menu.png') center/contain no-repeat;
      box-shadow: 0 2px 6px rgba(0,0,0,.4);
      font-size: 0;
    }

    #stats {
      display: none;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 1px 3px rgba(0,0,0,.7);
      padding: 0 2px;
    }
    #status-text {
      display: none;
      font-weight: 600;
    }

    #canvas-container {
      position: absolute;
      inset: 0;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* –ó–∞—Å—Ç–∞–≤–∫–∞ */
    #splash {
      position: fixed;
      inset: 0;
      background: #000 url('assets/splash_bg.png') center/cover no-repeat;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      transition: opacity 0.4s ease;
    }
    #splash.hidden {
      opacity: 0;
      pointer-events: none;
    }
    #splash-inner {
      width: 100%;
      max-width: 360px;
      padding: 24px 20px calc(24px + env(safe-area-inset-bottom));
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 16px;
      color: #ffffff;
      text-shadow: 0 2px 6px rgba(0,0,0,0.7);
    }
    #splash-logo {
      font-size: 24px;
      font-weight: 800;
      letter-spacing: 1.5px;
    }
    #splash-logo span {
      font-size: 30px;
      margin-right: 6px;
    }
    #splash-subtitle {
      font-size: 14px;
      opacity: 0.9;
    }
    #splash-hint {
      font-size: 12px;
      opacity: 0.7;
    }
    /* –ö–Ω–æ–ø–∫–∞ –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É –ö–†–£–ü–ù–ï–ï (2.5x) */
    #splash-start-btn {
      margin: 8px auto 0;
      padding: 0;
      width: 550px;    /* –±—ã–ª–æ 220 */
      height: 150px;   /* –±—ã–ª–æ 60 */
      max-width: 100%; /* —á—Ç–æ–±—ã –Ω–µ –≤—ã–ª–µ–∑–∞–ª–∞ –∑–∞ —ç–∫—Ä–∞–Ω */
      background: url('assets/btn_splash_start.png') center/contain no-repeat;
      border-radius: 0;
      box-shadow: none;
      font-size: 0;
    }

    /* –ù–∏–∂–Ω–µ–µ —Ç–∞–±–ª–æ ‚Äî —É–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É, —á—Ç–æ–±—ã –≤–ª–µ–∑–ª–∞ –æ–≥—Ä–æ–º–Ω–∞—è Play */
    #bottom-ui {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      min-height: 140px;  /* –±—ã–ª–æ 80 */
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: space-around;
      padding: 8px 10px calc(8px + env(safe-area-inset-bottom, 0px));
      z-index: 2000;
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }
    #bottom-ui, #bottom-ui * {
      color: #ffffff;
    }
    .bottom-item {
      font-size: 16px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      gap: 2px;
      pointer-events: auto;
    }
    .bottom-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.7;
      letter-spacing: .06em;
    }
    .bottom-value {
      font-size: 18px;
      font-weight: 700;
    }
    #bottom-bet, #auto-toggle {
      cursor: pointer;
    }

    /* –ö–Ω–æ–ø–∫–∞ Play –ö–†–£–ü–ù–ï–ï (2x) */
    #start-round-btn {
      width: 160px;   /* –±—ã–ª–æ 80 */
      height: 160px;  /* –±—ã–ª–æ 80 */
      padding: 0;
      border-radius: 50%;
      background: url('assets/btn_play.png') center/contain no-repeat;
      box-shadow: 0 4px 14px rgba(0,0,0,0.65);
      font-size: 0;
    }
    #start-round-btn:disabled {
      opacity: 0.4;
      box-shadow: none;
      filter: grayscale(1);
    }

    /* –ö–Ω–æ–ø–∫–∞ "–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞" –ö–†–£–ü–ù–ï–ï (3x) */
    #retry-btn {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, 120%);
      padding: 0;
      width: 600px;    /* –±—ã–ª–æ 200 */
      height: 180px;   /* –±—ã–ª–æ 60 */
      max-width: 90%;  /* —á—Ç–æ–±—ã –≤–ª–µ–∑–∞–ª–∞ –Ω–∞ —ç–∫—Ä–∞–Ω */
      border-radius: 0;
      font-size: 0;
      background: url('assets/btn_retry.png') center/contain no-repeat;
      border: none;
      box-shadow: 0 4px 10px rgba(0,0,0,0.7);
      z-index: 2100;
      display: none;
    }
    #retry-btn:active {
      transform: translate(-50%, 120%) scale(0.97);
    }

    /* –ú–µ–Ω—é —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É */
    #menu-panel {
      position: absolute;
      top: 52px;
      right: 10px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 16px;
      padding: 12px;
      display: none;
      flex-direction: column;
      gap: 8px;
      z-index: 2100;
      min-width: 190px;
      backdrop-filter: blur(10px);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }
    #menu-panel.open {
      display: flex;
    }
    .menu-item {
      width: 180px;
      height: 48px;
      padding: 0;
      border-radius: 999px;
      background-position: center;
      background-repeat: no-repeat;
      background-size: contain;
      box-shadow: none;
      font-size: 0;
      background-color: transparent;
    }
    #menu-deposit {
      background-image: url('assets/btn_deposit.png');
    }
    #menu-withdraw {
      background-image: url('assets/btn_withdraw.png');
    }
  </style>
</head>
<body>
  <!-- –ó–∞—Å—Ç–∞–≤–∫–∞ -->
  <div id="splash">
    <div id="splash-inner">
      <div id="splash-logo"><span>üèùÔ∏è</span>–†–û–ë–ò–ù–ó–û–ù</div>
      <div id="splash-subtitle">
        –õ–µ—Ç–∏ –∫ –æ—Å—Ç—Ä–æ–≤—É, —Å–æ–±–∏—Ä–∞–π –±–æ–Ω—É—Å—ã –∏ —É–º–Ω–æ–∂–∞–π –≤—ã–∏–≥—Ä—ã—à.
      </div>
      <button id="splash-start-btn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
      <div id="splash-hint">
        –°–æ–≤–µ—Ç: –≤—ã–±–µ—Ä–∏ —Å—Ç–∞–≤–∫—É (–≤–Ω–∏–∑—É —Å–ø—Ä–∞–≤–∞), –∞ –∑–∞—Ç–µ–º –∂–º–∏ ‚ñ∂.
      </div>
    </div>
  </div>

  <!-- –í–µ—Ä—Ö–Ω–∏–π UI -->
  <div id="ui">
    <div id="ui-top">
      <div id="logo">–†–æ–±–∏–Ω–∑–æ–Ω</div>
      <div id="auth-panel">
        <button id="menu-btn" aria-label="–ú–µ–Ω—é"></button>
      </div>
    </div>

    <div id="stats">
      <div>–ú–Ω–æ–∂–∏—Ç–µ–ª—å: <span id="multiplier">1.00x</span></div>
      <div id="balance-box">–ë–∞–ª–∞–Ω—Å: <span id="balance">0.00</span> ü™ô</div>
    </div>
    <div id="status-text">–°–¥–µ–ª–∞–π —Å—Ç–∞–≤–∫—É –∏ –Ω–∞–∂–º–∏ ‚ñ∂</div>
  </div>

  <!-- –ú–µ–Ω—é -->
  <div id="menu-panel">
    <button class="menu-item" id="menu-deposit">Deposit</button>
    <button class="menu-item" id="menu-withdraw">Withdraw</button>
  </div>

  <!-- –ù–∏–∂–Ω–µ–µ —Ç–∞–±–ª–æ -->
  <div id="bottom-ui">
    <div class="bottom-item" id="bottom-balance">
      <div class="bottom-label">Balance</div>
      <div class="bottom-value" id="balance-bottom">0.00</div>
    </div>

    <button id="start-round-btn">‚ñ∂</button>

    <div class="bottom-item" id="bottom-bet">
      <div class="bottom-label">Bet</div>
      <div class="bottom-value" id="bet-bottom">1.00</div>
    </div>

    <div class="bottom-item" id="auto-toggle">
      <div class="bottom-label">Auto</div>
      <div class="bottom-value" id="auto-status">Off</div>
    </div>
  </div>

  <button id="retry-btn">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>

  <div id="canvas-container">
    <canvas id="game"></canvas>
  </div>

  <!-- –ó–≤—É–∫–∏ -->
  <audio id="splash-sound" src="assets/splash.mp3" preload="auto"></audio>
  <audio id="win-sound" src="assets/win.mp3" preload="auto"></audio>
  <audio id="bonus-sound" src="assets/bonus_hit.mp3" preload="auto"></audio>
  <audio id="bird-sound" src="assets/bird_hit.mp3" preload="auto"></audio>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const multiplierEl = document.getElementById("multiplier");
    const statusEl = document.getElementById("status-text");
    const startBtn = document.getElementById("start-round-btn");
    const balanceEl = document.getElementById("balance");
    const balanceBottomEl = document.getElementById("balance-bottom");
    const betBottomEl = document.getElementById("bet-bottom");
    const retryBtn = document.getElementById("retry-btn");

    const autoToggleEl = document.getElementById("auto-toggle");
    const autoStatusEl = document.getElementById("auto-status");

    const splash = document.getElementById("splash");
    const splashStartBtn = document.getElementById("splash-start-btn");

    const menuBtn = document.getElementById("menu-btn");
    const menuPanel = document.getElementById("menu-panel");
    const menuDepositBtn = document.getElementById("menu-deposit");
    const menuWithdrawBtn = document.getElementById("menu-withdraw");

    const splashSound = document.getElementById("splash-sound");
    const winSound = document.getElementById("win-sound");
    const bonusSound = document.getElementById("bonus-sound");
    const birdSound = document.getElementById("bird-sound");

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function loadImage(src) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.src = src;
        img.onload = () => res(img);
        img.onerror = rej;
      });
    }

    const assets = {};
    const ASSET_LIST = {
      bg: "assets/bg_ocean.png",
      rob: "assets/robinson.png",
      island: "assets/island_long.png",
      bird: "assets/bird_spritesheet.png",
      x2: "assets/bonus_x2.png",
      x3: "assets/bonus_x3.png",
      x5: "assets/bonus_x5.png",
      x10: "assets/bonus_x10.png",
      x20: "assets/bonus_x20.png",
      x50: "assets/bonus_x50.png",
      x100: "assets/bonus_x100.png",
      gameover: "assets/game_over.png",
      win: "assets/win.png"
    };

    let allLoaded = false;

    (async function preload() {
      for (const [key, src] of Object.entries(ASSET_LIST)) {
        assets[key] = await loadImage(src).catch(() => null);
      }
      allLoaded = true;
      statusEl.textContent = "–ì–æ—Ç–æ–≤–æ –∫ –∏–≥—Ä–µ";
      initProfile();
    })();

    let state = "idle"; // idle | flying | won | lost
    let robinson;
    let objects;
    let time;
    let lastTs;
    let multiplier;
    let baseBet = 1;

    let userBalance = 100;

    const HERO_X_REL = 0.25;
    const OBJECT_SPEED = 380;
    const ISLAND_BASE_PROB = 0.012;

    const BIRD_PROB   = 0.06;
    const BONUS_PROB  = 0.06;

    const WATER_LINE_REL = 0.8;
    const GRAVITY_BASE = 75;
    let gravity = GRAVITY_BASE;

    let bonusPulse = 0;
    let robinsonAnimTime = 0;
    let cameraY = 0;
    let cameraLockY = null;

    let splashParticles = [];
    let hasSplashed = false;
    let heroVisible = true;

    let gameOverAnimTime = 0;
    let winAnimTime = 0;

    let bonusParticles = [];
    let shakeTime = 0;

    // RTP
    let totalBet = 0;
    let totalPayout = 0;
    const TARGET_RTP = 0.96;
    let roundHistory = [];

    // –∞–≤—Ç–æ–∏–≥—Ä–∞
    let autoPlay = false;
    let autoRestartTimer = 0;

    function getCurrentRTP() {
      if (totalBet <= 0) return TARGET_RTP;
      return totalPayout / totalBet;
    }

    function getRTPFactor() {
      if (totalBet < 50) return 1;
      const current = getCurrentRTP();
      const diff = TARGET_RTP - current;
      let factor = 1 + diff * 0.7;
      if (factor < 0.5) factor = 0.5;
      if (factor > 1.6) factor = 1.6;
      return factor;
    }

    function updateHistoryUI() {
      // –∏—Å—Ç–æ—Ä–∏—è –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è
      return;
    }

    function resetRound() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      robinson = {
        x: w * HERO_X_REL,
        y: h * 0.5,
        vy: -170,
        width: 72,
        height: 72,
      };

      gravity = GRAVITY_BASE;
      objects = [];
      splashParticles = [];
      hasSplashed = false;
      heroVisible = true;
      time = 0;
      multiplier = 1;
      lastTs = performance.now();
      bonusPulse = 0;
      robinsonAnimTime = 0;
      cameraY = 0;
      cameraLockY = null;
      gameOverAnimTime = 0;
      winAnimTime = 0;
      autoRestartTimer = 0;
      shakeTime = 0;
      multiplierEl.textContent = "1.00x";

      retryBtn.style.display = "none";

      const baseX = w * 0.55;
      const spacing = 150;
      const startBonuses = ["x2", "x3", "x5", "x2", "x10", "x3"];
      const bonusSize = 38;

      startBonuses.forEach((kind, i) => {
        const yOffset = (Math.random() * 0.12 - 0.06) * h;
        objects.push({
          type: "bonus",
          kind,
          x: baseX + i * spacing,
          y: robinson.y + yOffset,
          w: bonusSize,
          h: bonusSize,
          phase: Math.random() * Math.PI * 2,
        });
      });
    }

    function initProfile() {
      userBalance = 100;
      updateBalanceUI();
      statusEl.textContent = "–î–µ–º–æ-—Ä–µ–∂–∏–º: —É —Ç–µ–±—è 100 –º–æ–Ω–µ—Ç";
      betBottomEl.textContent = baseBet.toFixed(2);
      updateHistoryUI();
    }

    function updateBalanceUI() {
      balanceEl.textContent = userBalance.toFixed(2);
      balanceBottomEl.textContent = userBalance.toFixed(2);
    }

    // –ú–µ–Ω—é
    menuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      menuPanel.classList.toggle("open");
    });

    document.addEventListener("click", (e) => {
      if (!menuPanel.contains(e.target) && e.target !== menuBtn) {
        // –µ—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –∞–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏–µ, —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π
        // menuPanel.classList.remove("open");
      }
    });

    menuDepositBtn.addEventListener("click", () => {
      const amountStr = prompt("–ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å (–º–æ–Ω–µ—Ç—ã):");
      const amount = parseFloat(amountStr || "0");
      if (!amount || amount <= 0) return;
      userBalance += amount;
      updateBalanceUI();
      statusEl.textContent = "–ë–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω";
    });

    menuWithdrawBtn.addEventListener("click", () => {
      const amountStr = prompt("–í—ã–≤–µ—Å—Ç–∏ –±–∞–ª–∞–Ω—Å (–º–æ–Ω–µ—Ç—ã):");
      const amount = parseFloat(amountStr || "0");
      if (!amount || amount <= 0) return;
      if (amount > userBalance) {
        alert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –≤—ã–≤–æ–¥–∞");
        return;
      }
      userBalance -= amount;
      updateBalanceUI();
      statusEl.textContent = "–ë–∞–ª–∞–Ω—Å –≤—ã–≤–µ–¥–µ–Ω";
    });

    document.getElementById("bottom-bet").addEventListener("click", () => {
      const valueStr = prompt("–í–≤–µ–¥–∏—Ç–µ —Å—Ç–∞–≤–∫—É", baseBet.toFixed(2));
      const val = parseFloat(valueStr || "");
      if (!val || val <= 0) return;
      baseBet = val;
      betBottomEl.textContent = baseBet.toFixed(2);
    });

    autoToggleEl.addEventListener("click", () => {
      autoPlay = !autoPlay;
      autoStatusEl.textContent = autoPlay ? "On" : "Off";
    });

    function startRound() {
      if (!allLoaded) return;

      if (userBalance < baseBet) {
        statusEl.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç. –ü–æ–ø–æ–ª–Ω–∏ –±–∞–ª–∞–Ω—Å.";
        return;
      }

      totalBet += baseBet;
      userBalance -= baseBet;
      updateBalanceUI();

      resetRound();
      state = "flying";
      statusEl.textContent = "–†–æ–±–∏–Ω–∑–æ–Ω –≤ –ø–æ–ª—ë—Ç–µ...";
      startBtn.disabled = true;

      const unlockSound = (audio) => {
        if (!audio) return;
        audio.play().then(() => {
          audio.pause();
          audio.currentTime = 0;
        }).catch(() => {});
      };
      unlockSound(splashSound);
      unlockSound(winSound);
      unlockSound(bonusSound);
      unlockSound(birdSound);
    }

    startBtn.addEventListener("click", () => {
      if (state === "idle" || state === "won" || state === "lost") {
        startRound();
      }
    });

    retryBtn.addEventListener("click", () => {
      startRound();
    });

    splashStartBtn.addEventListener("click", () => {
      splash.classList.add("hidden");
    });

    function finishRound(result) {
      let winAmount = 0;
      if (result === "won") {
        winAmount = baseBet * multiplier;
        userBalance += winAmount;
        totalPayout += winAmount;
        updateBalanceUI();
      }
      roundHistory.unshift({
        result,
        bet: baseBet,
        multiplier,
        win: winAmount
      });
      if (roundHistory.length > 12) roundHistory.pop();
      updateHistoryUI();
    }

    function getLastOfType(type) {
      for (let i = objects.length - 1; i >= 0; i--) {
        if (objects[i].type === type) return objects[i];
      }
      return null;
    }

    function spawnIsland() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const width = 260;
      const height = 80;
      const y = h * WATER_LINE_REL;

      const x = w + width * 0.6;
      const last = getLastOfType("island");
      const minGap = 260;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "island",
        x,
        y,
        w: width,
        h: height,
      });
    }

    function spawnBird() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const size = 58;
      const y = h * (0.18 + Math.random() * 0.37);
      const x = w + size * 0.8;
      const last = getLastOfType("bird");
      const minGap = 180;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "bird",
        x,
        y,
        w: size,
        h: size,
        phase: Math.random() * Math.PI * 2,
      });
    }

    const BONUS_WEIGHTS = [
      { key: "x2",   w: 40 },
      { key: "x3",   w: 30 },
      { key: "x5",   w: 15 },
      { key: "x10",  w: 8  },
      { key: "x20",  w: 4  },
      { key: "x50",  w: 2  },
      { key: "x100", w: 1  },
    ];

    function randomBonusKey(rtpFactor) {
      const factor = rtpFactor || 1;
      const weights = BONUS_WEIGHTS.map(b => ({ ...b }));

      for (const b of weights) {
        if (b.key === "x10" || b.key === "x20" || b.key === "x50" || b.key === "x100") {
          b.w *= factor;
        }
      }

      let total = 0;
      for (const b of weights) total += b.w;
      let r = Math.random() * total;
      for (const b of weights) {
        if (r < b.w) return b.key;
        r -= b.w;
      }
      return "x2";
    }

    function spawnBonus(rtpFactor) {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const size = 38;
      const y = h * (0.22 + Math.random() * 0.38);
      const x = w + size * 0.6;
      const last = getLastOfType("bonus");
      const minGap = 220;

      if (last && last.x - x < minGap) return;

      objects.push({
        type: "bonus",
        kind: randomBonusKey(rtpFactor),
        x,
        y,
        w: size,
        h: size,
        phase: Math.random() * Math.PI * 2,
      });
    }

    function isColliding(a, b) {
      return !(
        a.x + a.w < b.x ||
        a.x > b.x + b.w ||
        a.y + a.h < b.y ||
        a.y > b.y + b.h
      );
    }

    function createSplash(x, waterY) {
      const count = 22;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI - Math.PI / 2;
        const speed = 180 + Math.random() * 140;
        splashParticles.push({
          x,
          y: waterY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed * 0.8,
          life: 0,
          maxLife: 0.7 + Math.random() * 0.3,
          r: 2 + Math.random() * 3,
        });
      }
    }

    function addBonusParticles(x, y) {
      const count = 18;
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 70;
        bonusParticles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0,
          maxLife: 0.5 + Math.random() * 0.2,
        });
      }
    }

    function vibrate(pattern) {
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
    }

    function update(dt) {
      time += dt;
      bonusPulse = Math.max(0, bonusPulse - dt);
      robinsonAnimTime += dt;
      if (shakeTime > 0) shakeTime = Math.max(0, shakeTime - dt);

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const waterY = h * WATER_LINE_REL;

      for (const p of splashParticles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 350 * dt;
        p.life += dt;
      }
      splashParticles = splashParticles.filter(p => p.life < p.maxLife);

      for (const p of bonusParticles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.life += dt;
      }
      bonusParticles = bonusParticles.filter(p => p.life < p.maxLife);

      if ((state === "won" || state === "lost") && autoPlay) {
        autoRestartTimer += dt;
        if (autoRestartTimer > 1.5 && !startBtn.disabled && userBalance >= baseBet) {
          autoRestartTimer = 0;
          startRound();
          return;
        }
      }

      if (state === "idle" || state === "won") {
        cameraY = -(robinson.y - h * 0.55) * 0.1;
        cameraLockY = null;
        if (state === "won") winAnimTime += dt;
        return;
      }

      if (state === "lost") {
        if (cameraLockY === null) {
          cameraLockY = cameraY;
        }
        cameraY = cameraLockY;
        gameOverAnimTime += dt;
        return;
      }

      // FLYING
      robinson.vy += gravity * dt;
      robinson.y += robinson.vy * dt;

      const topLimit = h * 0.12;
      if (robinson.y < topLimit) {
        robinson.y = topLimit;
        if (robinson.vy < 0) robinson.vy = 0;
      }

      // –ø–∞–¥–µ–Ω–∏–µ –≤ –≤–æ–¥—É = –ø—Ä–æ–∏–≥—Ä—ã—à
      if (robinson.y + robinson.height / 2 >= waterY) {
        state = "lost";
        statusEl.textContent = "–†–æ–±–∏–Ω–∑–æ–Ω —É–ø–∞–ª –≤ –≤–æ–¥—É";
        startBtn.disabled = false;
        if (!hasSplashed) {
          createSplash(robinson.x, waterY);
          hasSplashed = true;
        }
        heroVisible = false;
        finishRound("lost");
        retryBtn.style.display = "block";
        gameOverAnimTime = 0;

        if (splashSound) {
          splashSound.currentTime = 0;
          splashSound.play().catch(() => {});
        }
        vibrate(200);
        return;
      }

      const rtpFactor = getRTPFactor();

      const islandProb = Math.max(
        0.0005,
        ISLAND_BASE_PROB / (1 + multiplier * 0.1)
      ) * (rtpFactor > 1 ? 1.15 : 0.9);

      const birdProb  = BIRD_PROB;
      const bonusProb = BONUS_PROB * (rtpFactor > 1 ? 1.2 : 0.8);

      if (Math.random() < islandProb) spawnIsland();
      if (Math.random() < birdProb)  spawnBird();
      if (Math.random() < bonusProb) spawnBonus(rtpFactor);

      const dx = OBJECT_SPEED * dt;
      objects.forEach((o) => { o.x -= dx; });

      const heroBox = {
        x: robinson.x - robinson.width * 0.35,
        y: robinson.y - robinson.height * 0.35,
        w: robinson.width * 0.7,
        h: robinson.height * 0.7,
      };

      for (const o of objects) {
        const ow = o.w * 0.8;
        const oh = o.h * 0.8;
        const box = {
          x: o.x - ow / 2,
          y: o.y - oh / 2,
          w: ow,
          h: oh,
        };

        if (!isColliding(heroBox, box)) continue;

        if (o.type === "island") {
          state = "won";
          statusEl.textContent = "–ü–æ–±–µ–¥–∞! –†–æ–±–∏–Ω–∑–æ–Ω –ø—Ä–∏–∑–µ–º–ª–∏–ª—Å—è –Ω–∞ –æ—Å—Ç—Ä–æ–≤";
          startBtn.disabled = false;
          retryBtn.style.display = "block";
          winAnimTime = 0;
          finishRound("won");

          if (winSound) {
            winSound.currentTime = 0;
            winSound.play().catch(() => {});
          }
          vibrate([80, 60, 80]);
          break;
        }

        if (o.type === "bird") {
          multiplier = Math.max(1, multiplier / 2);
          multiplierEl.textContent = multiplier.toFixed(2) + "x";
          statusEl.textContent = "–ü—Ç–∏—Ü–∞! –í—ã–∏–≥—Ä—ã—à —É–º–µ–Ω—å—à–µ–Ω";
          gravity = Math.min(gravity + 50, GRAVITY_BASE * 2.5);
          robinson.vy += 50;
          o._dead = true;

          if (birdSound) {
            birdSound.currentTime = 0;
            birdSound.play().catch(() => {});
          }
          shakeTime = 0.25;
        }

        if (o.type === "bonus") {
          const val = parseInt(o.kind.slice(1));
          multiplier *= val;
          multiplierEl.textContent = multiplier.toFixed(2) + "x";
          statusEl.textContent = "–ë–æ–Ω—É—Å " + o.kind + "!";
          robinson.vy = -230;
          gravity = Math.max(GRAVITY_BASE * 0.8, gravity - 20);
          bonusPulse = 0.25;
          addBonusParticles(o.x, o.y);
          o._dead = true;

          if (bonusSound) {
            bonusSound.currentTime = 0;
            bonusSound.play().catch(() => {});
          }
        }
      }

      objects = objects.filter(o => o.x + o.w > -50 && !o._dead);

      cameraY = -(robinson.y - h * 0.55) * 0.1;
      cameraLockY = null;
    }

    function drawBackground() {
      const bg = assets.bg;
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      if (bg) {
        const scale = h / bg.height;
        const imgW = bg.width * scale;
        for (let x = 0; x < w + imgW; x += imgW) {
          ctx.drawImage(bg, x, cameraY * 0.15, imgW, h);
        }
      } else {
        ctx.fillStyle = "#4cc3ff";
        ctx.fillRect(0, 0, w, h);
      }
    }

    function drawWaterRegion() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const worldWaterY = h * WATER_LINE_REL;
      const baseY = worldWaterY + cameraY;

      const waveAmp = 6;
      const waveLen = 80;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(-40, baseY + Math.sin(time * 2) * 2);
      for (let x = -40; x <= w + 40; x += 20) {
        const y = baseY + Math.sin((x / waveLen) + time * 2) * waveAmp;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w + 40, h);
      ctx.lineTo(-40, h);
      ctx.closePath();

      const g = ctx.createLinearGradient(0, baseY, 0, h);
      g.addColorStop(0, "rgba(0, 130, 220, 0.95)");
      g.addColorStop(0.4, "rgba(0, 90, 180, 0.98)");
      g.addColorStop(1, "rgba(0, 40, 90, 1)");

      ctx.fillStyle = g;
      ctx.fill();
      ctx.restore();
    }

    function drawSplash() {
      if (!splashParticles.length) return;
      ctx.save();
      for (const p of splashParticles) {
        const alpha = 1 - p.life / p.maxLife;
        if (alpha <= 0) continue;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(230, 245, 255, 1)";
        ctx.beginPath();
        ctx.arc(p.x, p.y + cameraY, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawBonusParticles() {
      if (!bonusParticles.length) return;
      ctx.save();
      for (const p of bonusParticles) {
        const alpha = 1 - p.life / p.maxLife;
        if (alpha <= 0) continue;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "rgba(255, 220, 120, 1)";
        ctx.beginPath();
        ctx.arc(p.x, p.y + cameraY, 2.2, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawHero() {
      if (!heroVisible) return;
      const img = assets.rob;
      if (!img) return;

      const pulse = bonusPulse > 0 ? (bonusPulse / 0.25) : 0;
      const tilt = Math.sin(robinsonAnimTime * 6) * 0.18;
      const bobY = Math.sin(robinsonAnimTime * 3) * 4;
      const scale = 1 + 0.25 * pulse;

      ctx.save();
      ctx.translate(robinson.x, robinson.y + bobY + cameraY);
      ctx.rotate(tilt);
      ctx.scale(scale, scale);

      ctx.drawImage(
        img,
        -robinson.width / 2,
        -robinson.height / 2,
        robinson.width,
        robinson.height
      );

      ctx.restore();
    }

    function drawWinAboveHero() {
      if (!heroVisible) return;
      const px = robinson.x;
      const py = robinson.y + cameraY - robinson.height * 0.6;

      const winNow = baseBet * multiplier;
      const text = winNow.toFixed(2) + " RUB";

      ctx.save();
      ctx.font = "bold 20px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.strokeStyle = "rgba(0,0,0,0.8)";
      ctx.lineWidth = 4;
      ctx.strokeText(text, px, py);
      const grad = ctx.createLinearGradient(px - 30, py - 10, px + 30, py + 10);
      grad.addColorStop(0, "#ffe082");
      grad.addColorStop(1, "#ffffff");
      ctx.fillStyle = grad;
      ctx.fillText(text, px, py);
      ctx.restore();
    }

    function drawObjects() {
      for (const o of objects) {
        let drawY = o.y;

        if (o.type === "bonus" || o.type === "bird") {
          const amp = o.type === "bonus" ? 4 : 6;
          const freq = o.type === "bonus" ? 3 : 2.5;
          drawY = o.y + Math.sin(time * freq + (o.phase || 0)) * amp;
        }

        if (o.type === "island" && assets.island) {
          ctx.drawImage(
            assets.island,
            o.x - o.w / 2,
            o.y - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
        if (o.type === "bonus" && assets[o.kind]) {
          ctx.drawImage(
            assets[o.kind],
            o.x - o.w / 2,
            drawY - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
        if (o.type === "bird" && assets.bird) {
          ctx.drawImage(
            assets.bird,
            o.x - o.w / 2,
            drawY - o.h / 2 + cameraY,
            o.w,
            o.h
          );
        }
      }
    }

    function drawGameOverOverlay() {
      if (state !== "lost") return;

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const t = Math.min(gameOverAnimTime / 0.5, 1);
      const ease = 1 - Math.pow(1 - t, 3);

      ctx.save();

      ctx.globalAlpha = 0.65 * ease;
      ctx.fillStyle = "rgba(0, 0, 0, 1)";
      ctx.fillRect(0, 0, w, h);

      const img = assets.gameover;
      ctx.globalAlpha = ease;

      if (img) {
        const maxW = w * 0.75;
        const maxH = h * 0.5;
        const baseScale = Math.min(maxW / img.width, maxH / img.height);
        const scale = baseScale * (0.9 + 0.1 * ease);

        const iw = img.width * scale;
        const ih = img.height * scale;
        const x = w / 2 - iw / 2;
        const y = h / 2 - ih / 2;

        ctx.drawImage(img, x, y, iw, ih);
      }

      ctx.restore();
    }

    function drawWinOverlay() {
      if (state !== "won") return;

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      const t = Math.min(winAnimTime / 0.5, 1);
      const ease = 1 - Math.pow(1 - t, 3);

      ctx.save();

      ctx.globalAlpha = 0.55 * ease;
      ctx.fillStyle = "rgba(0, 0, 0, 1)";
      ctx.fillRect(0, 0, w, h);

      const img = assets.win;

      const cx = w / 2;
      const cy = h * 0.32;

      ctx.globalAlpha = 0.65 * ease;
      const glowRadius = 120;
      const grad = ctx.createRadialGradient(
        cx, cy, 0,
        cx, cy, glowRadius
      );
      grad.addColorStop(0, "rgba(255, 220, 120, 1)");
      grad.addColorStop(0.4, "rgba(255, 180, 60, 0.9)");
      grad.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.9 * ease;
      const sparkleCount = 10;
      for (let i = 0; i < sparkleCount; i++) {
        const angle = time * 1.5 + (i * (Math.PI * 2 / sparkleCount));
        const baseR = 70;
        const wobble = Math.sin(time * 3 + i) * 8;
        const r = baseR + wobble;

        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;

        const size = 3 + Math.sin(time * 4 + i) * 1.2;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle * 2);

        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, size);
        ctx.strokeStyle = "rgba(255, 245, 200, 1)";
        ctx.lineWidth = 1.2;
        ctx.stroke();

        ctx.restore();
      }

      ctx.globalAlpha = ease;
      if (img) {
        const maxW = w * 0.75;
        const maxH = h * 0.5;
        const baseScale = Math.min(maxW / img.width, maxH / img.height);
        const scale = baseScale * (0.9 + 0.12 * ease);

        const iw = img.width * scale;
        const ih = img.height * scale;

        const x = cx - iw / 2;
        const y = cy - ih / 2;

        ctx.drawImage(img, x, y, iw, ih);
      } else {
        ctx.font = "bold 26px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.strokeStyle = "rgba(0,0,0,0.8)";
        ctx.lineWidth = 4;
        ctx.strokeText("–¢—ã –ø–æ–±–µ–¥–∏–ª!", cx, cy);
        ctx.fillStyle = "#ffffff";
        ctx.fillText("–¢—ã –ø–æ–±–µ–¥–∏–ª!", cx, cy);
      }

      ctx.restore();
    }

    function render() {
      const now = performance.now();
      const dt = (now - lastTs) / 1000;
      lastTs = now;

      update(dt);

      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      ctx.clearRect(0, 0, w, h);

      ctx.save();
      if (shakeTime > 0) {
        const t = shakeTime / 0.25;
        const strength = 6 * t;
        const sx = (Math.random() * 2 - 1) * strength;
        const sy = (Math.random() * 2 - 1) * strength;
        ctx.translate(sx, sy);
      }

      drawBackground();
      drawWaterRegion();
      drawObjects();
      drawHero();
      drawWinAboveHero();
      drawBonusParticles();
      drawSplash();
      drawGameOverOverlay();
      drawWinOverlay();

      ctx.restore();

      requestAnimationFrame(render);
    }

    lastTs = performance.now();
    resetRound();
    requestAnimationFrame(render);
  </script>
</body>
</html>
